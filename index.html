<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" 
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Tetranel — Infinite Visualizer</title>
<style>
  html,body {
    margin:0; padding:0; height:100%; width:100%;
    overflow:hidden; background:#000;
    overscroll-behavior:none;
    touch-action:none; /* Prevent Safari/Chrome gestures */
  }
  canvas {
    width:100%; height:100%; display:block;
    touch-action:none; /* Disable pinch zoom/page pan */
  }
  .overlay {
    position:absolute; top:10px; left:10px; right:10px;
    font-family:system-ui, sans-serif;
    color:#dfefffcc; background:rgba(0,0,0,0.35);
    padding:10px; border-radius:8px; font-size:13px; line-height:1.3;
    pointer-events:none;
  }
  .credits {
    position:absolute; bottom:10px; right:10px;
    font-family:system-ui, sans-serif;
    color:#a9d0ff88; background:rgba(0,0,0,0.35);
    font-size:11px; padding:4px 8px; border-radius:6px;
    pointer-events:none;
  }
  .kbd { background:rgba(255,255,255,0.1); padding:2px 5px; border-radius:4px; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="overlay">
  <b>Tetranel — infinite segments</b><br>
  <span class="kbd">Drag</span> move · <span class="kbd">Pinch</span> zoom<br>
  <span class="kbd">Double-tap</span> reset view
</div>
<div class="credits">Mobile + Desktop WebGL fractal demo</div>

<script>
(() => {
  const M_VALUE = 5194759284829473.0; // the "bound" number
  const MAX_ZOOM_IN = 16.0;
  const MIN_ZOOM_OUT = 1e-20;

  const canvas = document.getElementById("c");
  const gl = canvas.getContext("webgl", {antialias:false});
  if (!gl) { document.body.innerHTML="WebGL not supported"; return; }

  function resize() {
    const dpr = Math.min(window.devicePixelRatio||1, 2.5);
    const w = Math.floor(innerWidth*dpr);
    const h = Math.floor(innerHeight*dpr);
    if (canvas.width!==w || canvas.height!==h) {
      canvas.width=w; canvas.height=h;
      gl.viewport(0,0,w,h);
    }
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  const vs = `attribute vec2 a_pos; void main(){gl_Position=vec4(a_pos,0.0,1.0);} `;
  const fs = `
  precision highp float;
  uniform vec2 u_resolution;
  uniform float u_time;
  uniform vec2 u_offset;
  uniform float u_zoom;
  uniform float u_M;

  vec3 palette(float t){
    vec3 b=vec3(0.03,0.18,0.45);
    vec3 w=vec3(1.0);
    vec3 k=vec3(0.0);
    return (t<0.5)?mix(b,w,smoothstep(0.0,0.5,t))
                  :mix(w,k,smoothstep(0.5,1.0,t));
  }
  float hash21(vec2 p){
    p=fract(p*vec2(123.34,456.21));
    p+=dot(p,p+45.32);
    return fract(p.x*p.y);
  }

  void main(){
    vec2 uv=(gl_FragCoord.xy/u_resolution.xy)*2.0-1.0;
    uv.x*=u_resolution.x/u_resolution.y;

    float zoom=u_zoom;
    vec2 world=(uv/zoom)+u_offset;

    vec2 tile=floor(world*u_M);
    float h=hash21(tile);
    float v=sin(dot(tile,vec2(0.7,1.1))+u_time*0.05)+h;
    v=fract(v*1.23);

    // Blue-white-black gradient
    vec3 col=palette(v);
    gl_FragColor=vec4(pow(col,vec3(0.9)),1.0);
  }`;

  function makeShader(type,src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
      throw gl.getShaderInfoLog(s);
    return s;
  }
  const prog=gl.createProgram();
  gl.attachShader(prog,makeShader(gl.VERTEX_SHADER,vs));
  gl.attachShader(prog,makeShader(gl.FRAGMENT_SHADER,fs));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
    -1,-1, 1,-1, -1,1,
     1,-1, 1,1, -1,1
  ]),gl.STATIC_DRAW);

  const loc=gl.getAttribLocation(prog,"a_pos");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  const uRes=gl.getUniformLocation(prog,"u_resolution");
  const uTime=gl.getUniformLocation(prog,"u_time");
  const uOff=gl.getUniformLocation(prog,"u_offset");
  const uZoom=gl.getUniformLocation(prog,"u_zoom");
  const uM=gl.getUniformLocation(prog,"u_M");

  let offset={x:0,y:0}, zoom=1.0;
  let t0=performance.now();

  // Desktop: mouse controls
  let dragging=false, lastX=0, lastY=0;
  canvas.addEventListener("mousedown",e=>{
    dragging=true; lastX=e.clientX; lastY=e.clientY;
  });
  window.addEventListener("mouseup",()=>dragging=false);
  window.addEventListener("mousemove",e=>{
    if(dragging){
      offset.x -= (e.clientX-lastX)/canvas.height*2/zoom;
      offset.y += (e.clientY-lastY)/canvas.height*2/zoom;
      lastX=e.clientX; lastY=e.clientY;
    }
  });
  canvas.addEventListener("wheel",e=>{
    const factor=Math.exp(-e.deltaY*0.001);
    zoom=Math.max(MIN_ZOOM_OUT,Math.min(MAX_ZOOM_IN,zoom*factor));
    e.preventDefault();
  },{passive:false});

  // Mobile: pinch + drag + double tap reset
  let lastTouches=[];
  let lastTap=0;
  canvas.addEventListener("touchstart",e=>{
    if(e.touches.length===1 && e.timeStamp-lastTap<300){
      offset={x:0,y:0}; zoom=1.0; // reset
    }
    lastTap=e.timeStamp;
    lastTouches=[...e.touches].map(t=>({x:t.clientX,y:t.clientY,id:t.identifier}));
  },{passive:false});

  canvas.addEventListener("touchmove",e=>{
    if(e.touches.length===1 && lastTouches.length===1){
      let t=e.touches[0], lt=lastTouches[0];
      offset.x -= (t.clientX-lt.x)/canvas.height*2/zoom;
      offset.y += (t.clientY-lt.y)/canvas.height*2/zoom;
    }
    if(e.touches.length===2 && lastTouches.length===2){
      let [a,b]=e.touches, [la,lb]=lastTouches;
      let d0=Math.hypot(la.x-lb.x,la.y-lb.y);
      let d1=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
      if(d0>0){
        zoom*=d1/d0;
        zoom=Math.max(MIN_ZOOM_OUT,Math.min(MAX_ZOOM_IN,zoom));
      }
    }
    lastTouches=[...e.touches].map(t=>({x:t.clientX,y:t.clientY,id:t.identifier}));
    e.preventDefault();
  },{passive:false});

  function draw(t){
    resize();
    gl.uniform2f(uRes,canvas.width,canvas.height);
    gl.uniform1f(uTime,(t-t0)/1000.0);
    gl.uniform2f(uOff,offset.x,offset.y);
    gl.uniform1f(uZoom,zoom);
    gl.uniform1f(uM,M_VALUE);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
