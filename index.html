<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" 
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Tractal — Tetranel Fractal</title>
<style>
  html,body { margin:0; padding:0; height:100%; width:100%;
    overflow:hidden; background:#000; overscroll-behavior:none; touch-action:none; }
  canvas { width:100%; height:100%; display:block; touch-action:none; }
  .overlay {
    position:absolute; top:10px; left:10px; right:10px;
    font-family:system-ui,sans-serif; font-size:13px;
    background:rgba(0,0,0,0.4); color:#fff; padding:6px 10px;
    border-radius:8px; pointer-events:none;
  }
  .controls { position:absolute; bottom:20px; left:20px;
    display:flex; flex-direction:column; gap:8px; }
  .btn { width:48px; height:48px; border-radius:24px;
    background:rgba(0,0,0,0.6); color:#fff;
    font-size:24px; display:flex; align-items:center; justify-content:center;
    user-select:none; cursor:pointer; }
  .btn:active { background:rgba(255,255,255,0.25); }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="overlay">Tractal — Tetranel fractal explorer</div>
<div class="controls">
  <div class="btn" id="zoomIn">＋</div>
  <div class="btn" id="zoomOut">－</div>
  <div class="btn" id="reset">⟳</div>
</div>

<script>
(() => {
  const M_VALUE = 5194759284829473.0;
  const canvas = document.getElementById("c");
  const gl = canvas.getContext("webgl");
  if (!gl) { document.body.innerHTML="WebGL not supported"; return; }

  function resize() {
    const dpr = Math.min(window.devicePixelRatio||1, 2.5);
    canvas.width = innerWidth*dpr;
    canvas.height = innerHeight*dpr;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener("resize", resize); resize();

  const vs = `attribute vec2 a_pos; void main(){gl_Position=vec4(a_pos,0.0,1.0);} `;
  const fs = `
  precision highp float;
  uniform vec2 u_resolution;
  uniform vec2 u_offset;
  uniform float u_zoom;
  uniform float u_M;

  // hash from Tetranel index
  float hash(float n){ return fract(sin(n*43758.5453)*43758.5453); }

  vec3 palette(float t){
    vec3 b=vec3(0.1,0.2,0.7);
    vec3 w=vec3(1.0);
    vec3 k=vec3(0.0);
    return mix(mix(b,w,smoothstep(0.0,0.5,t)), k, smoothstep(0.5,1.0,t));
  }

  void main(){
    vec2 uv=(gl_FragCoord.xy/u_resolution.xy)*2.0-1.0;
    uv.x*=u_resolution.x/u_resolution.y;

    // world coordinates
    vec2 world=(uv/u_zoom)+u_offset;

    // Tetranel index
    float idx = floor(world.x*10000.0 + world.y*100000.0);
    float val = mod(idx, u_M);
    float seed = hash(val);

    // Iteration (Tractal recursion)
    vec2 z = vec2(0.0);
    vec2 c = vec2(world.x+seed*0.2, world.y+seed*0.2);
    int maxIter = 100;
    float i;
    for(i=0.0;i<float(maxIter);i++){
      z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
      if(dot(z,z)>4.0) break;
    }

    float t = i/float(maxIter);
    vec3 col = palette(t);
    gl_FragColor=vec4(col,1.0);
  }`;

  function makeShader(type,src){
    const s=gl.createShader(type); gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  }
  const prog=gl.createProgram();
  gl.attachShader(prog,makeShader(gl.VERTEX_SHADER,vs));
  gl.attachShader(prog,makeShader(gl.FRAGMENT_SHADER,fs));
  gl.linkProgram(prog); gl.useProgram(prog);

  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,-1,1,1,-1,1]),gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(prog,"a_pos");
  gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  const uRes=gl.getUniformLocation(prog,"u_resolution");
  const uOff=gl.getUniformLocation(prog,"u_offset");
  const uZoom=gl.getUniformLocation(prog,"u_zoom");
  const uM=gl.getUniformLocation(prog,"u_M");

  let offset={x:0,y:0}, zoom=1.0;

  // Buttons
  document.getElementById("zoomIn").onclick=()=>zoom*=1.25;
  document.getElementById("zoomOut").onclick=()=>zoom/=1.25;
  document.getElementById("reset").onclick=()=>{offset={x:0,y:0};zoom=1.0;};

  // Dragging
  let dragging=false,lastX=0,lastY=0;
  canvas.addEventListener("mousedown",e=>{dragging=true;lastX=e.clientX;lastY=e.clientY;});
  window.addEventListener("mouseup",()=>dragging=false);
  window.addEventListener("mousemove",e=>{
    if(dragging){
      offset.x-=(e.clientX-lastX)/canvas.height*2/zoom;
      offset.y+=(e.clientY-lastY)/canvas.height*2/zoom;
      lastX=e.clientX; lastY=e.clientY;
    }
  });

  // Touch (drag + pinch)
  let lastTouches=[];
  canvas.addEventListener("touchstart",e=>{
    lastTouches=[...e.touches].map(t=>({x:t.clientX,y:t.clientY}));
  },{passive:false});
  canvas.addEventListener("touchmove",e=>{
    if(e.touches.length===1 && lastTouches.length===1){
      let t=e.touches[0],lt=lastTouches[0];
      offset.x-=(t.clientX-lt.x)/canvas.height*2/zoom;
      offset.y+=(t.clientY-lt.y)/canvas.height*2/zoom;
    }
    if(e.touches.length===2 && lastTouches.length===2){
      let [a,b]=e.touches,[la,lb]=lastTouches;
      let d0=Math.hypot(la.x-lb.x,la.y-lb.y);
      let d1=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
      if(d0>0) zoom*=d1/d0;
    }
    lastTouches=[...e.touches].map(t=>({x:t.clientX,y:t.clientY}));
    e.preventDefault();
  },{passive:false});

  function draw(){
    resize();
    gl.uniform2f(uRes,canvas.width,canvas.height);
    gl.uniform2f(uOff,offset.x,offset.y);
    gl.uniform1f(uZoom,zoom);
    gl.uniform1f(uM,M_VALUE);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
